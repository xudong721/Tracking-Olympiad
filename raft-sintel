import os
import cv2
import csv
import torch
import numpy as np
from argparse import Namespace
from raft import RAFT
import torchvision.transforms.functional as TF

# ==== 图像预处理（不再 resize，保留原始大小） ====
def preprocess_frame(frame):
    frame_tensor = TF.to_tensor(frame).unsqueeze(0)
    return 2 * frame_tensor - 1.0

# ==== 自动 padding 到 8 的倍数（RAFT 要求） ====
def pad_images(image1, image2):
    h, w = image1.shape[-2:]
    pad_h = (((h // 8) + 1) * 8 - h) % 8
    pad_w = (((w // 8) + 1) * 8 - w) % 8
    image1 = torch.nn.functional.pad(image1, [0, pad_w, 0, pad_h])
    image2 = torch.nn.functional.pad(image2, [0, pad_w, 0, pad_h])
    return image1, image2

# ==== 加载 RAFT 模型 ====
def load_model(model_path, device):
    args = Namespace(
        small=False,
        mixed_precision=False,
        alternate_corr=False,
        dropout=0.0,
        corr_levels=4,
        corr_radius=4
    )
    model = RAFT(args)
    # 删除 module. 前缀
    raw = torch.load(model_path, map_location=device)
    state_dict = {k.replace("module.", ""): v for k, v in raw.items()}
    model.load_state_dict(state_dict)
    model.to(device)
    model.eval()
    return model

# ==== 光流计算（返回 flow HxWx2） ====
def compute_flow(model, image1, image2, device):
    image1 = image1.to(device)
    image2 = image2.to(device)
    image1, image2 = pad_images(image1, image2)
    with torch.no_grad():
        _, flow_up = model(image1, image2, iters=12, test_mode=True)
    return flow_up[0].permute(1, 2, 0).cpu().numpy()

# ==== 可视化光流（可选调试） ====
def flow_to_color(flow):
    mag, ang = cv2.cartToPolar(flow[..., 0], flow[..., 1])
    hsv = np.zeros((flow.shape[0], flow.shape[1], 3), dtype=np.uint8)
    hsv[..., 0] = ang * 180 / np.pi / 2
    hsv[..., 1] = 255
    hsv[..., 2] = cv2.normalize(mag, None, 0, 255, cv2.NORM_MINMAX)
    return cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)

# ==== 主流程 ====
def track_hexbug(video_path, output_csv, output_video, model_path, motion_threshold=0.8, min_area=20):
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    print(f"[INFO] 使用设备: {device}")
    model = load_model(model_path, device)

    cap = cv2.VideoCapture(video_path)
    ret, prev = cap.read()
    if not ret:
        print("❌ 无法读取视频")
        return

    H, W, _ = prev.shape
    fps = cap.get(cv2.CAP_PROP_FPS)
    writer = cv2.VideoWriter(output_video, cv2.VideoWriter_fourcc(*'XVID'), fps, (W, H))

    os.makedirs("flow_vis", exist_ok=True)

    index = 0
    trajectory = []
    last_known = (-1, -1)

    with open(output_csv, 'w', newline='') as f:
        csv_writer = csv.writer(f)
        csv_writer.writerow(['', 't', 'hexbug', 'x', 'y'])

        while True:
            ret, curr = cap.read()
            if not ret:
                break

            image1 = preprocess_frame(prev)
            image2 = preprocess_frame(curr)
            flow = compute_flow(model, image1, image2, device)

            # === 可视化光流（可选）===
            flow_vis = flow_to_color(flow)
            cv2.imwrite(f"flow_vis/frame_{index:04d}.png", flow_vis)

            mag, _ = cv2.cartToPolar(flow[..., 0], flow[..., 1])
            motion_mask = (mag > motion_threshold).astype(np.uint8) * 255
            contours, _ = cv2.findContours(motion_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

            # 过滤小目标
            contours = [c for c in contours if cv2.contourArea(c) > min_area]

            if contours:
                largest = max(contours, key=cv2.contourArea)
                M = cv2.moments(largest)
                if M["m00"] != 0:
                    cx = int(M["m10"] / M["m00"])
                    cy = int(M["m01"] / M["m00"])
                    last_known = (cx, cy)
                else:
                    cx, cy = last_known
            else:
                cx, cy = last_known

            # 轨迹可视化
            if cx != -1 and cy != -1:
                trajectory.append((cx, cy))
                if len(trajectory) > 50:
                    trajectory.pop(0)
                for i in range(1, len(trajectory)):
                    cv2.line(curr, trajectory[i - 1], trajectory[i], (0, 255, 0), 2)
                cv2.circle(curr, (cx, cy), 4, (0, 0, 255), -1)
                csv_writer.writerow([index, index, 0, cx, cy])
            else:
                csv_writer.writerow([index, index, 0, -1, -1])

            writer.write(curr)
            prev = curr
            index += 1

    cap.release()
    writer.release()
    print("✅ Hexbug 跟踪完成，输出：", output_csv)

# ==== 示例调用 ====
if __name__ == "__main__":
    track_hexbug(
        video_path='training018.mp4',
        output_csv='output18.csv',
        output_video='output18.avi',
        model_path='raft-sintel.pth',
        motion_threshold=0.8,
        min_area=20
    )
